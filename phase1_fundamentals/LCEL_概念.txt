# LCEL LangChain expression language(LangChain表达式)：一种声明式的方法来链接LangChain组件
'''
标准接口：
stream: 流式返回响应的块
invoke: 在输入上调用链
batch: 在输入列表上调用链
组件	          输入类型	                    输出类型
提示词	      字典	                        提示值
聊天模型	      单个字符串、聊天消息列表或提示值	聊天消息
大型语言模型	  单个字符串、聊天消息列表或提示值	字符串
输出解析器	  LLM或聊天模型的输出	            取决于解析器
检索器	      单个字符串	                    文档列表
工具	          单个字符串或字典，取决于工具	    取决于工具

langchain表达式LCEL的核心是什么

LCEL（LangChain Expression Language）的核心是**声明式、可组合的链式构建范式**，通过三个关键设计实现：

1. **统一接口**
   所有组件（提示模板、模型、输出解析器等）均实现 `Runnable` 协议，提供标准化的 `invoke()`、`batch()`、`stream()` 方法，消除组件间的适配成本。

2. **函数式组合原语**
   提供 `|` 运算符（类似 Unix 管道）连接组件，例如：
   ```python
   chain = prompt | model | output_parser
   ```
   每个组合自动获得流式处理、批量运行、异步支持等能力。

3. **自动运行时优化**
   - 并行化：自动检测可并行执行的独立节点
   - 流式传输：逐 token 流式输出（无需额外配置）
   - 错误传播：结构化错误处理与重试机制

**关键优势**：
- **可维护性**：声明式语法清晰表达数据处理流程
- **可观测性**：内置 LangSmith 跟踪支持
- **生产就绪**：直接支持重试、超时、缓存等生产特性

示例体现设计哲学：
```python
from langchain_core.runnables import RunnablePassthrough

chain = (
    {"context": retriever, "question": RunnablePassthrough()}
    | prompt
    | model
    | StrOutputParser()
)
```
通过解耦数据流与控制流，LCEL 将链式构建从过程式代码提升为可复用、可调试的声明式工作流。

具体分为哪几部分？

LCEL 的结构化设计可分为以下四个核心部分：

---

### 1. **基础运行单元（Runnable Primitives）**
所有可组合对象均实现 `Runnable` 抽象基类，包含：
- **RunnableLambda**：包装任意函数（支持同步/异步）
- **RunnablePassthrough**：恒等传递或添加字段
- **RunnableParallel**：并行执行多个 Runnable
- **RunnableSequence**：显式定义顺序链（`|` 运算符的底层实现）

```python
from langchain_core.runnables import RunnableLambda

add_one = RunnableLambda(lambda x: x + 1)
```

---

### 2. **组合运算符（Composition Operators）**
通过运算符重载实现声明式组合：
- **`|`（管道）**：顺序组合 `A | B | C`
- **`+`（合并）**：合并两个 Runnable 的输出
- **`&`（并行）**：并行执行并合并结果（同 `RunnableParallel`）

```python
# 管道组合
chain = prompt | model | parser

# 并行组合
parallel_chain = RunnableParallel(
    context=retriever,
    question=RunnablePassthrough()
)
```

---

### 3. **运行时系统（Runtime System）**
自动为任何链提供以下能力：
- **流式处理**：通过 `stream()` 逐 token 输出
- **批量处理**：`batch()` 自动并行化独立输入
- **异步支持**：所有链原生支持 `ainvoke()`, `astream()`
- **错误处理**：内置 `with_retry()`, `with_fallbacks()`
- **配置传递**：通过 `RunnableConfig` 传递超时、重试等参数

```python
# 自动获得的能力
async for chunk in chain.astream(input):
    print(chunk)

# 配置传递
result = chain.invoke(
    input,
    config={"configurable": {"retry_count": 3}}
)
```

---

### 4. **类型系统与验证（Type System）**
基于 Pydantic 的强类型保障：
- **输入/输出模式**：每个 Runnable 声明 `input_schema` 和 `output_schema`
- **自动验证**：运行时验证数据类型
- **可视化支持**：可通过 `chain.get_graph().print_ascii()` 查看数据流类型

```python
# 查看链的输入输出类型
print(chain.input_schema.schema())
print(chain.output_schema.schema())
```

---

### 设计哲学体现
LCEL 通过这四个部分的协同，实现 **“组合优于继承”** ：
1. **任意组件可组合**：无论来源（LangChain、自定义、第三方），只要实现 `Runnable` 即可接入
2. **声明式即生产就绪**：简单 `|` 组合自动获得流式、批量、异步等生产特性
3. **数据流可视化**：类型系统使复杂链的数据流可推导、可调试

这种设计使开发者从过程式胶水代码中解放，专注于业务逻辑的组合与声明。

实际开发中要学习到什么水平？

实际开发中，掌握LCEL应达到以下三个层次，按优先级排序：

---

### **第一层：基础应用（必备，1-2天掌握）**
**目标**：能替换传统 `LLMChain`，构建生产级链
**核心技能**：
1. **管道操作符**：熟练使用 `|` 连接标准组件
   ```python
   # 替代 LLMChain(prompt, llm, parser)
   chain = prompt | llm | output_parser
   ```
2. **基础Runnable**：掌握 `RunnablePassthrough`、`RunnableParallel` 的常见模式
   ```python
   # 检索增强生成（RAG）标准模式
   rag_chain = (
       {"context": retriever, "question": RunnablePassthrough()}
       | prompt
       | llm
       | parser
   )
   ```
3. **生产方法调用**：
   - `invoke()`：同步调用
   - `ainvoke()`：异步调用
   - `stream()`/`astream()`：流式输出
   - `batch()`：批量处理

**学习产出**：能重构现有 `LLMChain` 为LCEL，获得自动流式/批量支持

---

### **第二层：进阶模式（2-3周熟练）**
**目标**：处理复杂业务逻辑，优化性能
**核心技能**：
1. **条件逻辑与路由**：
   ```python
   from langchain_core.runnables import RunnableBranch

   branch = RunnableBranch(
       (lambda x: x["topic"] == "tech", tech_chain),
       (lambda x: x["topic"] == "business", biz_chain),
       default_chain
   )
   ```
2. **状态管理与记忆**：
   ```python
   # 会话记忆模式
   from langchain_core.runnables import RunnableWithMessageHistory

   chain_with_history = RunnableWithMessageHistory(
       chain,
       get_session_history,
       input_messages_key="input",
       history_messages_key="history"
   )
   ```
3. **性能优化**：
   - 识别并行化机会（`RunnableParallel`）
   - 配置重试与回退：`chain.with_retry()`
   - 实现自定义缓存层

**学习产出**：能设计多分支对话系统、带状态的复杂工作流

---

### **第三层：深度定制（专家级，1-2个月）**
**目标**：扩展LCEL生态，解决边缘场景
**核心技能**：
1. **自定义Runnable**：
   ```python
   from langchain_core.runnables import RunnableSerializable

   class CustomRunnable(RunnableSerializable[str, str]):
       def invoke(self, input: str, config=None) -> str:
           # 自定义逻辑
           return processed_input

       # 必须实现流式方法以支持stream()
       async def astream(self, input: str, config=None):
           yield chunk
   ```
2. **高级类型控制**：
   - 定义复杂的输入/输出 Pydantic 模型
   - 实现类型转换链（`RunnableLambda` + 类型注解）
3. **调试与监控**：
   - 集成 LangSmith 跟踪
   - 实现自定义回调处理器
   - 使用 `chain.get_graph()` 分析数据流

**学习产出**：能封装企业特定组件，构建可维护的大型AI应用框架

---

### **实际开发中的学习建议**
1. **立即开始使用**：新项目直接采用LCEL，旧项目逐步迁移
2. **掌握调试技巧**：
   ```python
   # 调试神器：查看中间结果
   debug_chain = prompt | llm | {"raw": RunnablePassthrough(), "parsed": parser}
   ```
3. **关注关键文档**：
   - [LCEL概念指南](https://python.langchain.com/docs/expression_language/)
   - [Runnable协议API](https://python.langchain.com/api_reference/core/runnables/)
   - [生产部署指南](https://python.langchain.com/docs/guides/production/)

**验收标准**：
- ✅ 能流畅阅读官方LCEL示例代码
- ✅ 能设计包含条件/并行/状态的标准业务链
- ✅ 能为团队编写LCEL最佳实践指南

LCEL的学习曲线前期陡峭但回报显著：掌握后开发效率提升3-5倍，且代码更易维护。建议**边做边学**，从实际项目中的一个链开始重构。

